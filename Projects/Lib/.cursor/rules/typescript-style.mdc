---
description: 
globs: 
alwaysApply: true
---
TypeScript Style Guide

Strictness & Clarity

Explicit Types: Annotate all function parameters, return values, and variable declarations with explicit types. Avoid relying on implicit inference, except for simple, immediately assigned primitives/literals where the type is obvious (e.g., const name = 'foo';, const count = 0;).
No any: Strictly disallow both implicit and explicit any. Use unknown for values with truly unknown types and perform necessary type narrowing. Model complex types accurately.
Readonly by Default: Mark properties in interfaces and object types as readonly by default, especially for data structures, configuration, or state. Only make properties mutable if mutation is an intended and necessary part of their design.
Use as const for Static Data: For arrays or objects containing static, known data (like lookup tables, configuration, data definitions in src/code/data/), use "as const" to allow TypeScript to infer the most specific literal types and readonly status. For instance, an array of objects like internalData with code and value properties would be declared with "as const" at the end.

interface vs. type

Use interface for Object Shapes: Define the structure of objects, classes, and API contracts using interface. For example, an interface User might have readonly properties id (number) and name (string).
Use type for Other Cases: Use type for:
Unions (string | number)
Intersections (A & B)
Tuples ([string, number])
Aliases for primitives or complex non-object types (type UserID = string;)
Mapped or Conditional Types.
Function signature types (type Callback = () => void;).
Use type for Literal Unions (IntelliSense): When a parameter or variable should only accept a specific set of known string/number literals derived from "as const" data, create a type alias for the literal union and use that type for the annotation. This enables value-based IntelliSense. For example, in src/code/types/, you might import internalData from '@/code/data/codes' solely for type derivation, then define a type SpecificCode as (typeof internalData)[number]['code'], which would resolve to a union like 'A' | 'B'. This SpecificCode type would then be used in a function signature, like function processCode(code: SpecificCode).

Type Reusability

Use Defined Types: Always reuse existing, imported interface or type aliases. Do not redefine shapes inline if a suitable type already exists.
Check for Existing Types: Before creating a new type for function parameters or complex objects, check if an existing type (like RecipePayload) already serves the purpose. Avoid creating redundant types.

Documentation

JSDoc for Exports: Add JSDoc comments (/** ... */) to all exported members (interfaces, types, classes, functions, constants) explaining their purpose.
Inline Comments for "Why": Use inline comments (//) sparingly to explain the reasoning behind complex or non-obvious code, not just what the code does.
Keep Docs Updated: Ensure comments and JSDoc are updated or removed during refactoring.
