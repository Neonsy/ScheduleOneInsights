---
description: 
globs: 
alwaysApply: true
---
# TypeScript Style Guide

## Strictness & Clarity

1.  **Explicit Types:** Annotate all function parameters, return values, and variable declarations with explicit types. Avoid relying on implicit inference, except for simple, immediately assigned primitives/literals where the type is obvious (e.g., `const name = 'foo';`, `const count = 0;`).
2.  **No `any`:** Strictly disallow both implicit and explicit `any`. Use `unknown` for values with truly unknown types and perform necessary type narrowing. Model complex types accurately.
3.  **Readonly by Default:** Mark properties in interfaces and object types as `readonly` by default, especially for data structures, configuration, or state. Only make properties mutable if mutation is an intended and necessary part of their design.
4.  **Use `as const` for Static Data:** For arrays or objects containing static, known data (like lookup tables, configuration, data definitions in `src/code/data/`), use `as const` to allow TypeScript to infer the most specific literal types and `readonly` status.
    ```typescript
    // Example
    const internalData = [{ code: 'A', value: 1 }, { code: 'B', value: 2 }] as const;
    ```

## `interface` vs. `type`

1.  **Use `interface` for Object Shapes:** Define the structure of objects, classes, and API contracts using `interface`.
    ```typescript
    interface User { readonly id: number; readonly name: string; }
    ```
2.  **Use `type` for Other Cases:** Use `type` for:
    *   Unions (`string | number`)
    *   Intersections (`A & B`)
    *   Tuples (`[string, number]`)
    *   Aliases for primitives or complex non-object types (`type UserID = string;`)
    *   Mapped or Conditional Types.
    *   Function signature types (`type Callback = () => void;`).
3.  **Use `type` for Literal Unions (IntelliSense):** When a parameter or variable should only accept a specific set of known string/number literals derived from `as const` data, create a `type` alias for the literal union and use that type for the annotation. This enables value-based IntelliSense.
    ```typescript
    // In src/code/types/...
    import { internalData } from '@/code/data/codes'; // Import only for type derivation
    export type SpecificCode = (typeof internalData)[number]['code']; // 'A' | 'B'

    // In function signature
    function processCode(code: SpecificCode) { /* ... */ }
    ```

## Type Reusability

1.  **Use Defined Types:** Always reuse existing, imported `interface` or `type` aliases. Do not redefine shapes inline if a suitable type already exists.
2.  **Check for Existing Types:** Before creating a new type for function parameters or complex objects, check if an existing type (like `RecipePayload`) already serves the purpose. Avoid creating redundant types.

## Documentation

1.  **JSDoc for Exports:** Add JSDoc comments (`/** ... */`) to all exported members (interfaces, types, classes, functions, constants) explaining their purpose.
2.  **Inline Comments for "Why":** Use inline comments (`//`) sparingly to explain the *reasoning* behind complex or non-obvious code, not just *what* the code does.
3.  **Keep Docs Updated:** Ensure comments and JSDoc are updated or removed during refactoring.
